# Проверка гипотез в бизнесе

Исследовательский анализ данных сервиса проката самокатов GoFast: демография пользователей, поведение поездок, выручка по подпискам, проверка гипотез и рекомендации по увеличению лояльности.

**Описание данных**  

Таблица с пользователями `users_go.csv`
* `user_id` — уникальный идентификатор пользователя.
* `name` — имя пользователя.
* `age` — возраст.
* `city` — город.
* `subscription_type` — тип подписки: free, ultra.

Таблица с поездками `rides_go.csv`
* `user_id` — уникальный идентификатор пользователя.
* `distance` — расстояние в метрах, которое пользователь проехал в текущей сессии.
* `duration` — продолжительность сессии в минутах, то есть время с того момента, как пользователь нажал кнопку «Начать поездку», до того, как он нажал кнопку «Завершить поездку».
* `date` — дата совершения поездки.

Таблица с подписками `subscriptions_go.csv`
* `subscription_type` — тип подписки.
* `minute_price` — стоимость одной минуты поездки по этой подписке.
* `start_ride_price` — стоимость начала поездки.
* `subscription_fee` — стоимость ежемесячного платежа.

**Задача:** смоделировать распределение длительности поездок, предполагая, что оно подчиняется нормальному закону, и рассчитать критическую дистанцию, ниже которой находится 90% всех поездок.

---

## Задание 1. Загрузка данных  

#### Задача 1.1 Импорт библиотеки pandas
```
import pandas as pd
```

#### Задача 1.2 Чтение данных

Считаем и сохраним три датасета для работы с данными:
```
df_users_go = pd.read_csv('https://code.s3.yandex.net/datasets/users_go.csv')
df_rides_go = pd.read_csv('https://code.s3.yandex.net/datasets/rides_go.csv')
df_subscriptions_go = pd.read_csv('https://code.s3.yandex.net/datasets/subscriptions_go.csv')
```

#### Задача 1.3 Печать первых строк
```
# Вывод первых 5 строк каждого датафрейма
display(df_users_go.head())
display(df_rides_go.head())
display(df_subscriptions_go.head())
```

<img width="482" height="447" alt="image" src="https://github.com/user-attachments/assets/57dc1f77-bd60-4f4d-ba81-f1e1f0c25d3d" />

#### Задача 1.4 Подсчёт строк

Определим количество строк в каждом из трёх датафреймов. Это поможет оценить объём данных и выявить аномалии, например слишком малое количество записей.
```
# Подсчёт количества строк в каждом датафрейме
n_users = len(df_users_go)
n_rides = len(df_rides_go)
n_subscriptions = len(df_subscriptions_go)

# Вывод ответа
print(n_users, n_rides, n_subscriptions)
```
1565 18068 2

---

## Задание 2. Знакомство с данными и их предварительная подготовка  
Прежде чем начать анализ, важно убедиться в качестве предоставленных данных. 

#### Задача 2.1 Определение типов данных  
В датафрейме `df_rides_go` выведем типы данных каждой колонки стандартным атрибутом dtypes. Так мы проверим корректность типов и подготовим данные для дальнейшей обработки

<img width="590" height="181" alt="image" src="https://github.com/user-attachments/assets/408bd466-c3ec-43c9-8bf0-449e127d8e93" />

#### Задача 2.2 Преобразование формата даты  
Приведём столбец `date` в датафрейме `df_rides_go` к типу даты pandas, используя метод pd.to_datetime().

<img width="584" height="305" alt="image" src="https://github.com/user-attachments/assets/ed9c0d34-d2e7-4821-8114-cca91319055e" />

#### Задача 2.3 Создание столбца с месяцем  
На основе столбца `date` создадим новый столбец `month`, содержащий номер месяца. Это нужно для последующей группировки данных и анализа сезонных трендов.

<img width="601" height="355" alt="image" src="https://github.com/user-attachments/assets/3c76c189-786f-41b3-8d14-e08377002a4a" />

#### Задача 2.4 Поиск дублей и пропусков

В датафрейме пользователей `df_users_go` определим количество пропусков и дубликатов. Это необходимо для понимания полноты и уникальности данных пользователей. 

<img width="587" height="212" alt="image" src="https://github.com/user-attachments/assets/b9e6ac79-0f3e-405d-b26f-97fc36448d88" />

#### Задача 2.5 Заполнение пропусков и удаление дублей  
При наличии пропущенных значений заполним их нулями, а все дубликаты удалим. Это шаг необходим для улучшения качества данных.

<img width="533" height="350" alt="image" src="https://github.com/user-attachments/assets/eb7e6ce2-2a7c-409c-bc5e-45bac8f401ed" />

#### Задача 2.6 Округление длительности поездки  
В датафрейме поездок `df_rides_go округлим время поездки `duration` до целого числа стандартным методом round(). Затем приведём эту колонку к целочисленному типу `int`. Этот шаг затем поможет правильно рассчитать прибыль, так как плата взимается только за целое число минут.

<img width="606" height="633" alt="image" src="https://github.com/user-attachments/assets/350c0bd1-70b1-410d-b628-347243717f37" />

---

## Задание 3. Исследовательский анализ данных (EDA)  
В этом блоке мы внимательнее изучим и визуализируем информацию о географии и демографии сервиса, а также лучше поймём закономерности в дистанциях и длительности поездок.

#### Задача 3.1 Импорт библиотеки matplotlib

```
import matplotlib.pyplot as plt
```

#### Задача 3.2 Количество пользователей по городам.  
Пользуясь данными из датафрейма `df_users_go`, изучим количество пользователей в каждом из городов. Создадим и выведем на экран объект `pd.Series`, названный `users_by_city_count`, с одной колонкой `count` — суммарным количеством пользователей в каждом городе `city`, отсортированным по убыванию.

<img width="657" height="263" alt="image" src="https://github.com/user-attachments/assets/fd794fad-c9af-44d7-bf41-7d5550a1d66a" />

#### Задача 3.3 Количество пользователей подписки  
Создадим и выведем на экран серию `subscription_type_count` с количеством пользователей для каждого типа подписки `subscription_type`.

<img width="561" height="158" alt="image" src="https://github.com/user-attachments/assets/9985548f-9fe9-4022-bee9-02ebb0919bc4" />

#### Задача 3.4 Круговая диаграмма  
Построим круговую диаграмму, указав процент пользователей с `free` и `ultra` подпиской. Вызовем метод `plot()` для серии `subscription_type_count` с указанием нужного аргумента для построения круговой диаграммы.

<img width="604" height="421" alt="image" src="https://github.com/user-attachments/assets/326c2202-ddd8-4a2e-bf9d-80c149ab32ba" />

#### Задача 3.5 Гистограмма возрастов  
Построим гистограмму возрастов `age` пользователей самокатов. Используем количество бинов, равное разности максимального и минимального значений возраста.

<img width="587" height="579" alt="image" src="https://github.com/user-attachments/assets/0c55bcdf-ebbb-43f6-9fe2-fb50f3672932" />

#### Задача 3.6 Несовершеннолетние пользователи  
Рассчитаем долю несовершеннолетних (возрастом менее 18 лет) пользователей самокатов.

<img width="703" height="224" alt="image" src="https://github.com/user-attachments/assets/00a1e204-2eae-4af8-aee8-ff9251547818" />

#### Задача 3.7 Характеристики длительности поездки

Длительность поездки является важной метрикой в работе сервиса проката самокатов. Если средняя длительность поездок будет слишком высокой, самокаты будут быстрее выходить из строя. Если слишком низкой, значит, клиентам что-то не нравится в сервисе.

В этом задании с помощью описательной статистики изучим длительность поездок.

<img width="772" height="334" alt="image" src="https://github.com/user-attachments/assets/92344b77-4c28-46c7-802c-b050e61e15bd" />

---

## Задание 4. Объединение данных  

#### Задача 4.1 Объединение таблицы пользователей и поездок  
Объединим датафреймы с информацией о пользователях `df_users_go` и поездках `df_rides_go`. При объединении используем метод `merge()` по общей для двух таблиц колонке и тип объединения `left`.

<img width="522" height="112" alt="image" src="https://github.com/user-attachments/assets/69588e3c-fb98-4cda-b121-c68c1ade7119" />

#### Задача 4.2 Присоединение информации о подписках  
Присоединим к полученному датафрейму df информацию о подписках из df_subscriptions_go, используя метод merge() по общей колонке и тип объединения left.

<img width="486" height="123" alt="image" src="https://github.com/user-attachments/assets/d4a1d35d-0af3-4ec8-8271-380ccfb28f18" />

#### Задача 4.3. Размеры объединённого датафрейма  
Для финальной проверки выведем на экран первые пять строк датафрейма, а также количество строк и столбцов полученного датафрейма `df`. Этот этап позволит убедиться, что никакие записи не потерялись при объединении.

<img width="772" height="469" alt="image" src="https://github.com/user-attachments/assets/4923cb17-e949-409a-80f0-045dc6e76895" />

#### Задача 4.4 Отдельные датафреймы для пользователей с подпиской и без  
Создадим два вспомогательных датафрейма на основе `df`: первый только для пользователей с подпиской `df_ultra` и второй только для пользователей без подписки `df_free`. В следующих заданиях два этих датафрейма пригодятся при изучении поведения пользователей с подпиской и без, а также при проверке продуктовых гипотез.

<img width="441" height="236" alt="image" src="https://github.com/user-attachments/assets/1dd29610-dc59-4ba2-93e0-bcb418913ac0" />

#### Задача 4.5 Гистограмма длительности поездок для обоих групп  

<img width="703" height="749" alt="image" src="https://github.com/user-attachments/assets/22029f39-f7c0-4464-8ead-f0fd8c8bb0cb" />

---

## Задание 5. Подсчёт выручки  
Данные о количестве и длительности поездок объединены с ценами и тарифами, значит, теперь есть всё необходимое, чтобы рассчитать важный для бизнеса показатель — выручку.

#### Задача 5.1 Данные сгруппированные по нужным колонкам  
Сгруппируем данные по следующим столбцам: `user_id`, `name`, `subscription_type`, `month`. Группировку производём в датафрейме `df_gp`. В итоговом датафрейме `df_gp` должен сохраниться порядок агрегации изначальных столбцов и не должны использоваться групповые индексы (опция as_index=False).

<img width="707" height="633" alt="image" src="https://github.com/user-attachments/assets/3db8beaf-3d3d-47aa-b2f6-f99021108016" />

#### Задача 5.2 Подсчёт агрегированных метрик  
Создадим новый датафрейм `df_agg`. В нём для каждой группы рассчитаем и добавим в датафрейм следующие агрегированные значения, используя метод `agg()`.

<img width="707" height="516" alt="image" src="https://github.com/user-attachments/assets/3eb1c958-695c-4b7c-99c6-9d47484311ed" />

#### Задача 5.3 Функция для подсчёта выручки  
Создадим функцию `calculate_monthly_revenue(row)` для расчёта месячной выручки по формуле:

monthly_revenue = start_ride_price * rides_count + minute_price * total_duration + subscription_fee

В качестве входных данных функция будет принимать одну строку `row` датафрейма. 

<img width="648" height="274" alt="image" src="https://github.com/user-attachments/assets/49f28d6f-3507-41b7-9ac3-fd07b4e213db" />

#### Задача 5.4 Создание столбца с месячной выручкой на пользователя  
Создадим новый столбец с месячной выручкой на пользователя `monthly_revenue`. Для этого применим функцию `calculate_monthly_revenue(row)` к каждой строке агрегированного датафрейма `df_agg`.

<img width="703" height="289" alt="image" src="https://github.com/user-attachments/assets/3ba99c23-50f0-430a-b8f5-b7a32409db05" />

#### Задача 5.5 Поиск пользователя с максимальной выручкой  
Исследуем полученные значения выручки. Найдём пользователя с максимальной суммарной выручкой за весь период наблюдения и для него выведем на экран `user_id`, имя, месяц, количество поездок и выручку за каждый из месяцев.

<img width="498" height="527" alt="image" src="https://github.com/user-attachments/assets/38910346-0e0d-4f76-9be8-6e1f62c4c16f" />

---

## Задание 6. Проверка гипотез  

#### Задача 6.1 Импорт библиотеки SciPy

```
import scipy.stats as st
```

#### Задача 6.2 Вспомогательная функция для интерпретации результатов  
Напишем вспомогательную функцию `print_stattest_results(p_value, alpha)`, которая будет интерпретировать результаты статистического теста на основе p-value и заданного уровня значимости (α-уровня). Функция будет решать, следует ли принять альтернативную гипотезу или сохранить нулевую гипотезу.

У функции два параметра:
* p_value (тип float) — значение p-value, полученное в результате выполнения статистического теста.
* alpha (тип float, необязательный, по умолчанию alpha = 0.05) — уровень значимости статистического теста, который используется как порог для принятия решения об отклонении нулевой гипотезы.

Если принимаете альтернативную гипотезу, нужно вывести сообщение: 'Полученное значение p_value=<Введённое значение p_value> меньше критического уровня alpha=0.05. Принимаем альтернативную гипотезу.'

Если не можем опровергнуть нулевую гипотезу, нужно вывести сообщение: 'Полученное значение p_value=<Введённое значение p_value> больше критического уровня alpha=0.05. Опровергнуть нулевую гипотезу нельзя.'

Вызовем функцию для p_value = 0.0001 и p_value = 0.1.

<img width="700" height="291" alt="image" src="https://github.com/user-attachments/assets/faf393db-0452-4f3d-806b-b28b2383af17" />

#### Задача 6.3 Длительность для пользователей с подпиской и без  
Важно понять, тратят ли пользователи с подпиской больше времени на поездки?  Сформулируем нулевую и альтернативную гипотезы:
* Нулевая гипотеза (Н0): Среднее время поездки у пользователей с подпиской и без подписки одинаковое.
* Альтернативная гипотеза (Н1): Среднее время поездки у пользователей с подпиской больше, чем у пользователей без подписки.

Чтобы проверить эту гипотезу:
* Используем неагрегированные данные из датафреймов `df_ultra` и `df_free`, созданные на одном из прошлых шагов.
* Используем данные о продолжительности каждой поездки `duration` — отдельно для подписчиков и тех, у кого нет подписки.
* Рассчитаем значение `p_value` для выбранной гипотезы, используя функции модуля `scipy.stats` и односторонний t-тест.
* В качестве результата вызовем написанную функцию `print_stattest_results(p_value, alpha)`, передав ей рассчитанное значение `p_value`.
* В конце дополнительно рассчитаем среднюю длительность поездки для тарифов `ultra` и `free`, округлив её до двух знаков после точки стандартной функцией `round()`.

<img width="701" height="440" alt="image" src="https://github.com/user-attachments/assets/8b47b750-50f8-4773-beac-f1f391e9bbf1" />

#### Задача 6.4 Длительность поездки: больше или меньше критического значения  
Проанализируем ещё одну важную продуктовую гипотезу. Расстояние одной поездки в 3130 метров — оптимальное с точки зрения износа самоката. Можно ли сказать, что расстояние, которое проезжают пользователи с подпиской за одну поездку, меньше 3130 метров?

Сформулируем нулевую и альтернативную гипотезы:
* Нулевая гипотеза (Н0): Средняя дистанция поездки у пользователей с подпиской равна 3130 м.
* Альтернативная гипотеза (Н1): Средняя дистанция поездки у пользователей с подпиской больше 3130 м.

Чтобы проверить эту гипотезу:
* Используем неагрегированные данные о каждой поездке пользователей с подпиской из датафрейма `df_ultra`.
* Используем данные о дистанции каждой поездки `distance`.
* Рассчитаем значение `p_value` для выбранной гипотезы, используя функции модуля `scipy.stats` и односторонний t-тест. 
* В качестве результата вызовем написанную функцию `print_stattest_results(p_value, alpha)`, передав ей рассчитанное значение `p_value`.

<img width="697" height="332" alt="image" src="https://github.com/user-attachments/assets/ad81045b-1f93-470b-9b0f-90bce6676c4f" />

#### Задача 6.5 Прибыль от пользователей с подпиской и без  
Проверим гипотезу о том, что выручка от пользователей с подпиской выше, чем выручка от пользователей без подписки.

Сформулируем нулевую и альтернативную гипотезы:
* Нулевая гипотеза (Н0): Средняя месячная выручка у пользователей с подпиской и без подписки одинаковая.
* Альтернативная гипотеза (Н1): Средняя месячная выручка у пользователей с подпиской выше, чем у пользователей без подписки.

Чтобы проверить эту гипотезу:
* Используем агрегированные данные из датафрейма `df_agg`, подготовленного на шаге 5.
* Используем исходные данные о месячной выручке от каждого пользователя — `monthly_revenue`.
* Рассчитаем значение `p_value` для выбранной гипотезы, используя функции модуля `scipy.stats` и односторонний t-тест.
* В качестве результата вызовем написанную функцию `print_stattest_results(p_value, alpha)`, передав ей рассчитанное значение `p_value`.
* Дополнительно рассчитаем среднюю выручку для тарифов `ultra` и `free`, округлив её до целого стандартной функцией `round()`.

<img width="697" height="434" alt="image" src="https://github.com/user-attachments/assets/dc7994f4-eee7-4549-977b-ab261b239604" />

##  Задание 7. Распределения  
В компании возникла идея предлагать дополнительную скидку подписчикам, совершающим длительные поездки продолжительностью более 30 минут. Нас просят оценить долю таких поездок.

В одном из предыдущих заданий мы уже построили гистограмму распределения длительности поездок для выборки. Однако эти данные охватывают лишь часть пользователей всех самокатов, а нас интересуют возможные значения для всей генеральной совокупности. Учитывая, что у нас нет доступа ко всем данным о поездках, было решено смоделировать длительность поездки с помощью нормального распределения, используя в качестве параметров выборочное среднее и стандартное отклонение из доступных данных о поездках.

#### Задача 7.1 Расчёт выборочного среднего и стандартного отклонения  
* Расчитаем среднюю длительность поездки и сохраним в переменную `mu`.
* Вычислим стандартное отклонение длительности `duration` и сохраним в переменную `sigma`. Для вычисления стандартного отклонения можно применить метод std() к столбцу датасета.
* Зададим значение переменной `target_time`, равное 30. Эта переменная будет использоваться для последующего вычисления вероятности.
* округлим оба значения до одного знака после точки стандартной функцией round(). 

<img width="676" height="207" alt="image" src="https://github.com/user-attachments/assets/3889d87d-b63c-41e0-9617-82043ed7ba79" />

#### Задача 7.2 Вычисление значения функции распределения в точке (CDF)  
Если вычислить значение функции распределения в точке, это позволит узнать вероятность того, что случайная величина примет значение меньше заданного либо равное ему. 

* Используем функцию `norm()` из библиотеки SciPy для создания нормального распределения с параметрами `mu` и `sigma`.
* Применим метод cdf() к целевому времени `target_time` для получения вероятности того, что случайная величина будет меньше этого значения или равна ему. Полученное значение сохраним в переменную `prob`, округлив до трёх знаков после точки стандартной функцией round().

<img width="424" height="179" alt="image" src="https://github.com/user-attachments/assets/f922525c-6284-4d73-9c29-fb0327152322" />

#### Задача 7.3 Вероятность для интервала (CDF)  
Коллеги посчитали, что процент пользователей, для которых будет показана скидка, недостаточно большой и вряд ли поможет в увеличении лояльности клиентов. Дополнительно нас просят проверить, какой процент пользователей совершает поездки в интервале от 20 до 30 минут. Возможно, именно для них стоит провести промоакцию?

Для этого:
* Создадим переменные `low` и `high`, указывающие на начало и конец интересующего временного интервала. В этом случае они равны 20 и 30 минут.
* Используем кумулятивную функцию распределения (CDF) для объекта `duration_norm_dist`, чтобы вычислить вероятность достижения верхней границы (high) и нижней границы (low).
* Вычислим вероятность попадания в интервал, округлим до трёх знаков после точки стандартной функцией round() и сохраните в переменную `prob_interval`.

<img width="702" height="262" alt="image" src="https://github.com/user-attachments/assets/f436729b-91e5-40ec-a4ef-c6996413f89d" />

#### Задача 7.4 Определение критической дистанции поездок (PPF)  
Длительные поездки могут негативно сказываться на сроке службы самоката. В связи с этим принято решение установить критическую дистанцию, превышение которой будет сопровождаться дополнительной платой. Для этого необходимо определить расстояние, которое превышается только в 10% поездок (90-й процентиль).

Наша задача — смоделировать распределение длительности поездок, предполагая, что оно подчиняется нормальному закону, и рассчитать критическую дистанцию, ниже которой находится 90% всех поездок.

Для этого:
* Рассчитаем среднюю дистанцию поездки для всех пользователей из датафрейма `df` (с подпиской и без) и сохраним в переменную `mu`.
* Вычислим стандартное отклонение дистанции поездки `distance` и сохраним в переменную `sigma`. Для вычисления стандартного отклонения можно применить метод std() к столбцу датасета.
* Зададим значение переменной `target_prob`, равное 0.90. Эта переменная будет использоваться для последующего вычисления критической дистанции.
* Создадим объект нормального распределения `distance_norm` с заданными значениями `mu` и `sigma`.
* Применим к созданному нормальному распределению `distance_norm` метод ppf() и в качестве аргумента передадим целевую вероятность `target_prob`. Полученное значение сохраним в переменную `critical_distance`.

<img width="707" height="299" alt="image" src="https://github.com/user-attachments/assets/e3886e23-102f-4543-82ec-f85860b69277" />
